{"relation":[["Code","AF_ERROR_EOF","AF_ERROR_DATASMALL","AF_ERROR_TAIL","AF_ERROR_SEGH","AF_ERROR_NAME","AF_ERROR_INVALID_ARG","AF_ERROR_NO_AES","AF_ERROR_AES_TOO_SMALL","AF_ERROR_KEY_SET"],["Description","The end of the AFF file has been reached","The buffer provided for the requested AFF segment is not large enough to hold the data that would be returned.","There is no tail or an error occurred trying to read the tail of an AFF segment. This indicates that the file is corrupt (probably truncated).","There is no head or an error occurred trying to read the head. This indicates that the AFF file is corrupt.","Invalid segment name","The argument was invalid","This version of the library was compiled without AES support and the program is attempting to read an AES-encrypted segment.","The decrypted AES segment is too small for the amount of data that it was supposed to contain. The segment is probably corrupt.","A key was previously set. (You can only have one AES encryption key per file.)"]],"pageTitle":"Difference between revisions of \"AFF Developers Guide\" - ForensicsWiki","title":"","url":"http://www.forensicswiki.org/w/index.php?title\u003dAFF_Developers_Guide\u0026diff\u003d7279\u0026oldid\u003d7271","hasHeader":true,"headerPosition":"FIRST_ROW","tableType":"RELATION","tableNum":1,"s3Link":"common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042986423.95/warc/CC-MAIN-20150728002306-00159-ip-10-236-191-2.ec2.internal.warc.gz","recordEndOffset":463620703,"recordOffset":463605954,"tableOrientation":"HORIZONTAL","textBeforeTable":"The following status codes can be returned by AFF functions. AFF Return Values Pages AFF files can be viewed as a series of name/value pairs. Segments AFF Concepts This final line closes the file handle and destroys the AFFILE structure.  af_close(af);  This line uses one of the miscellaneous functions included with the AFF to display the size of the uncompressed image stored in the file. Compare the value displayed by this line to the size of the AFF image on the disk and you can see how much the library compresses. The example file zeros.aff shows an extreme case!  af_get_imagesize(af));  printf (\"The uncompressed size of this file is %\"PRId64\" bytes\\n\", This line attempts to open the given file using the af_open command. The O_RDONLY is one of many macros defined in fcntl.h that can be used when opening files. The final parameter specifies whether or not the file must be created. This normally only applies when writing AFF files, so it\u0027s safe to leave it as zero here. The function returns a pointer to an AFFILE structure. There are some public data fields in that structure defined in afflib.h.  } return TRUE; perror(fn); { if (NULL \u003d\u003d af)  AFFILE * af \u003d af_open(fn,O_RDONLY,0); These two lines include the necessary headers to use the AFF. Although fcntl.h is not actually required, it provides several macros that are highly recommended.","textAfterTable":"AFF Function Reference Stream Functions af_open  AFFILE * af_open(const char *filename, int flags, int mode); The flags parameter controls what the program should be allowed to do with the file. There are a set of handy macros defined in fcntl.h that you should use. When reading files, using O_RDONLY is usually sufficient. When writing an AFF file, it is best to use O_CREAT|O_RDWR. The mode parameter is only used when creating a new file (RBF – and only on *nix?). It controls the It should be noted here that when writing AFF files, the af_open command does more than just open a file handle. When writing, the af_open command causes the default AFF header to be written to the file on the disk. RBF – What happens, when opening for write, if the file already exists? RBF – Which parts of the header are written by default? See open(3) af_open_stdin  AFFILE * af_open_stdin(void); A special case of af_open, this function an AFF handle on standard input. Note that this function did not appear until AFF version 2.3. Also note that if you are working on the Windows platform (or plan to support the Windows platform) you need to explicitly tell the compiler to treat standard input as a stream of binary data. For example, using MinGW you can set:  int _CRT_fmode \u003d _O_BINARY; somewhere in","hasKeyColumn":false,"keyColumnIndex":-1,"headerRowIndex":0}