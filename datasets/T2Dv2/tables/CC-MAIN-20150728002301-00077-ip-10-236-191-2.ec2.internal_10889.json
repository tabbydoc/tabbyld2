{"relation":[["1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","310","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","366","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","388","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","422","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534","535","536","537","538","539","540","541","542","543","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560","561","562","563","564","565","566","567","568","569","570","571","572","573","574","575","576","577","578","579","580","581","582","583","584","585","586","587","588","589","590","591","592","593","594","595","596","597","598","599","600","601","602","603","604","605","606","607","608","609","610","611","612","613","614","615","616","617","618","619","620","621","622","623","624","625","626","627","628","629","630","631","632","633","634","635","636","637","638","639","640","641","642","643","644","645","646","647","648","649","650","651","652","653","654","655","656","657","658","659","660","661","662","663","664","665","666","667","668","669","670","671","672","673","674","675","676","677","678","679","680","681","682","683","684","685","686","687","688","689","690","691","692","693","694","695","696","697","698","699","700","701","702","703","704","705","706","707","708","709","710","711","712","713","714","715","716","717","718","719","720","721","722","723","724","725","726","727","728","729","730","731","732","733","734","735","736","737","738","739","740","741","742","743","744","745","746","747","748","749","750","751","752","753","754","755","756","757","758","759","760","761","762","763","764","765","766","767","768","769","770","771","772","773","774","775","776","777","778","779","780","781","782","783","784","785","786","787","788","789","790","791","792","793","794","795","796","797","798","799","800","801","802","803","804","805","806","807","808","809","810","811","812","813","814","815","816","817","818","819","820","821","822","823","824","825","826","827","828","829","830","831","832","833","834","835","836","837","838","839","840","841","842","843","844","845","846","847","848","849","850","851","852","853","854","855","856","857","858","859","860","861","862","863","864","865","866","867","868","869","870","871","872","873","874","875","876","877","878","879","880","881","882","883","884","885","886","887","888","889","890","891","892","893","894","895","896","897","898","899","900","901","902","903","904","905","906","907","908","909","910","911","912","913","914","915","916","917","918","919","920","921","922","923","924","925","926","927","928","929","930","931","932","933","934","935","936","937","938","939","940","941","942","943","944","945","946","947","948","949","950","951","952","953","954","955","956","957","958","959","960","961","962","963","964","965","966","967","968","969","970","971","972","973","974","975","976","977","978","979","980","981","982","983","984","985","986","987","988","989","990","991","992","993","994","995","996","997","998","999","1000","1001","1002","1003","1004","1005","1006","1007","1008","1009","1010","1011","1012","1013","1014","1015","1016","1017","1018","1019","1020","1021","1022","1023","1024","1025","1026","1027","1028","1029","1030","1031","1032","1033","1034","1035","1036","1037","1038","1039","1040","1041","1042","1043","1044","1045","1046","1047","1048","1049","1050","1051","1052","1053","1054","1055","1056","1057","1058","1059","1060","1061","1062","1063","1064","1065","1066","1067","1068","1069","1070","1071","1072","1073","1074","1075","1076","1077","1078","1079","1080","1081","1082","1083","1084","1085","1086","1087","1088","1089","1090","1091","1092","1093","1094","1095","1096","1097","1098","1099","1100","1101","1102","1103","1104","1105","1106","1107","1108","1109","1110","1111","1112","1113","1114","1115","1116","1117","1118","1119","1120","1121","1122","1123","1124","1125","1126","1127","1128","1129","1130","1131","1132","1133","1134","1135","1136","1137","1138","1139","1140","1141","1142","1143","1144","1145","1146","1147","1148","1149","1150","1151","1152","1153","1154","1155","1156","1157","1158","1159","1160","1161","1162","1163","1164","1165","1166","1167","1168","1169","1170","1171","1172","1173","1174","1175","1176","1177","1178","1179","1180","1181","1182","1183","1184","1185","1186","1187","1188","1189","1190","1191","1192","1193","1194","1195","1196","1197","1198","1199","1200","1201","1202","1203","1204","1205","1206","1207","1208","1209","1210","1211","1212","1213","1214","1215","1216","1217","1218","1219","1220","1221","1222","1223","1224","1225","1226","1227","1228","1229","1230","1231","1232","1233","1234","1235","1236","1237","1238","1239","1240","1241","1242","1243","1244","1245","1246","1247","1248","1249","1250","1251","1252","1253","1254","1255","1256","1257","1258","1259","1260","1261","1262","1263","1264","1265","1266","1267","1268","1269","1270","1271","1272","1273","1274","1275","1276","1277","1278","1279","1280","1281","1282","1283","1284","1285","1286","1287","1288","1289","1290","1291","1292","1293","1294","1295","1296","1297","1298","1299","1300","1301","1302","1303","1304","1305","1306","1307","1308","1309","1310","1311","1312","1313","1314","1315","1316","1317","1318","1319","1320","1321","1322","1323","1324","1325","1326","1327","1328","1329","1330","1331","1332","1333","1334","1335","1336","1337","1338","1339","1340","1341","1342","1343","1344","1345","1346","1347","1348","1349","1350","1351","1352","1353","1354","1355","1356","1357","1358","1359","1360","1361","1362","1363","1364","1365","1366","1367","1368","1369","1370","1371","1372","1373","1374","1375","1376","1377","1378","1379","1380","1381","1382","1383","1384","1385","1386","1387","1388","1389","1390","1391","1392","1393","1394","1395","1396","1397","1398","1399","1400","1401","1402","1403","1404","1405","1406","1407","1408","1409","1410","1411","1412","1413","1414","1415","1416","1417","1418","1419","1420","1421","1422","1423","1424","1425","1426","1427","1428","1429","1430","1431","1432","1433","1434","1435","1436","1437","1438","1439","1440","1441","1442","1443","1444","1445","1446","1447","1448","1449","1450","1451","1452","1453","1454","1455","1456","1457","1458","1459","1460","1461","1462","1463","1464","1465","1466","1467","1468","1469","1470","1471","1472","1473","1474","1475","1476","1477","1478","1479","1480","1481","1482","1483","1484","1485","1486","1487","1488","1489","1490","1491","1492","1493","1494","1495","1496","1497","1498","1499","1500","1501","1502","1503","1504","1505","1506","1507","1508","1509","1510","1511","1512","1513","1514","1515","1516","1517","1518","1519","1520","1521","1522","1523","1524","1525","1526","1527"],["/*************************************************","* Perl-Compatible Regular Expressions *","*************************************************/","","/* PCRE is a library of functions to support regular expressions whose syntax","and semantics are as close as possible to those of the Perl 5 language.","","Written by Philip Hazel","Copyright (c) 1997-2012 University of Cambridge","","-----------------------------------------------------------------------------","Redistribution and use in source and binary forms, with or without","modification, are permitted provided that the following conditions are met:","","* Redistributions of source code must retain the above copyright notice,","this list of conditions and the following disclaimer.","","* Redistributions in binary form must reproduce the above copyright","notice, this list of conditions and the following disclaimer in the","documentation and/or other materials provided with the distribution.","","* Neither the name of the University of Cambridge nor the names of its","contributors may be used to endorse or promote products derived from","this software without specific prior written permission.","","THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"","AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE","IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE","ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE","LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR","CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF","SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS","INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN","CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)","ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE","POSSIBILITY OF SUCH DAMAGE.","-----------------------------------------------------------------------------","*/","","","/* This module contains the external function pcre_study(), along with local","supporting functions. */","","","#ifdef HAVE_CONFIG_H","#include \"config.h\"","#endif","","#include \"pcre_internal.h\"","","#define SET_BIT(c) start_bits[c/8] |\u003d (1 \u003c\u003c (c\u00267))","","/* Returns from set_start_bits() */","","enum { SSB_FAIL, SSB_DONE, SSB_CONTINUE, SSB_UNKNOWN };","","","","/*************************************************","* Find the minimum subject length for a group *","*************************************************/","","/* Scan a parenthesized group and compute the minimum length of subject that","is needed to match it. This is a lower bound; it does not mean there is a","string of that length that matches. In UTF8 mode, the result is in characters","rather than bytes.","","Arguments:","code pointer to start of group (the bracket)","startcode pointer to start of the whole pattern","options the compiling options","int RECURSE depth","","Returns: the minimum length","-1 if \\C in UTF-8 mode or (*ACCEPT) was encountered","-2 internal error (missing capturing bracket)","-3 internal error (opcode not listed)","*/","","static int","find_minlength(const pcre_uchar *code, const pcre_uchar *startcode, int options,","int recurse_depth)","{","int length \u003d -1;","/* PCRE_UTF16 has the same value as PCRE_UTF8. */","BOOL utf \u003d (options \u0026 PCRE_UTF8) !\u003d 0;","BOOL had_recurse \u003d FALSE;","register int branchlength \u003d 0;","register pcre_uchar *cc \u003d (pcre_uchar *)code + 1 + LINK_SIZE;","","if (*code \u003d\u003d OP_CBRA || *code \u003d\u003d OP_SCBRA ||","*code \u003d\u003d OP_CBRAPOS || *code \u003d\u003d OP_SCBRAPOS) cc +\u003d IMM2_SIZE;","","/* Scan along the opcodes for this branch. If we get to the end of the","branch, check the length against that of the other branches. */","","for (;;)","{","int d, min;","pcre_uchar *cs, *ce;","register int op \u003d *cc;","","switch (op)","{","case OP_COND:","case OP_SCOND:","","/* If there is only one branch in a condition, the implied branch has zero","length, so we don\u0027t add anything. This covers the DEFINE \"condition\"","automatically. */","","cs \u003d cc + GET(cc, 1);","if (*cs !\u003d OP_ALT)","{","cc \u003d cs + 1 + LINK_SIZE;","break;","}","","/* Otherwise we can fall through and treat it the same as any other","subpattern. */","","case OP_CBRA:","case OP_SCBRA:","case OP_BRA:","case OP_SBRA:","case OP_CBRAPOS:","case OP_SCBRAPOS:","case OP_BRAPOS:","case OP_SBRAPOS:","case OP_ONCE:","case OP_ONCE_NC:","d \u003d find_minlength(cc, startcode, options, recurse_depth);","if (d \u003c 0) return d;","branchlength +\u003d d;","do cc +\u003d GET(cc, 1); while (*cc \u003d\u003d OP_ALT);","cc +\u003d 1 + LINK_SIZE;","break;","","/* ACCEPT makes things far too complicated; we have to give up. */","","case OP_ACCEPT:","case OP_ASSERT_ACCEPT:","return -1;","","/* Reached end of a branch; if it\u0027s a ket it is the end of a nested","call. If it\u0027s ALT it is an alternation in a nested call. If it is END it\u0027s","the end of the outer call. All can be handled by the same code. If an","ACCEPT was previously encountered, use the length that was in force at that","time, and pass back the shortest ACCEPT length. */","","case OP_ALT:","case OP_KET:","case OP_KETRMAX:","case OP_KETRMIN:","case OP_KETRPOS:","case OP_END:","if (length \u003c 0 || (!had_recurse \u0026\u0026 branchlength \u003c length))","length \u003d branchlength;","if (op !\u003d OP_ALT) return length;","cc +\u003d 1 + LINK_SIZE;","branchlength \u003d 0;","had_recurse \u003d FALSE;","break;","","/* Skip over assertive subpatterns */","","case OP_ASSERT:","case OP_ASSERT_NOT:","case OP_ASSERTBACK:","case OP_ASSERTBACK_NOT:","do cc +\u003d GET(cc, 1); while (*cc \u003d\u003d OP_ALT);","/* Fall through */","","/* Skip over things that don\u0027t match chars */","","case OP_REVERSE:","case OP_CREF:","case OP_NCREF:","case OP_RREF:","case OP_NRREF:","case OP_DEF:","case OP_CALLOUT:","case OP_SOD:","case OP_SOM:","case OP_EOD:","case OP_EODN:","case OP_CIRC:","case OP_CIRCM:","case OP_DOLL:","case OP_DOLLM:","case OP_NOT_WORD_BOUNDARY:","case OP_WORD_BOUNDARY:","cc +\u003d PRIV(OP_lengths)[*cc];","break;","","/* Skip over a subpattern that has a {0} or {0,x} quantifier */","","case OP_BRAZERO:","case OP_BRAMINZERO:","case OP_BRAPOSZERO:","case OP_SKIPZERO:","cc +\u003d PRIV(OP_lengths)[*cc];","do cc +\u003d GET(cc, 1); while (*cc \u003d\u003d OP_ALT);","cc +\u003d 1 + LINK_SIZE;","break;","","/* Handle literal characters and + repetitions */","","case OP_CHAR:","case OP_CHARI:","case OP_NOT:","case OP_NOTI:","case OP_PLUS:","case OP_PLUSI:","case OP_MINPLUS:","case OP_MINPLUSI:","case OP_POSPLUS:","case OP_POSPLUSI:","case OP_NOTPLUS:","case OP_NOTPLUSI:","case OP_NOTMINPLUS:","case OP_NOTMINPLUSI:","case OP_NOTPOSPLUS:","case OP_NOTPOSPLUSI:","branchlength++;","cc +\u003d 2;","#ifdef SUPPORT_UTF","if (utf \u0026\u0026 HAS_EXTRALEN(cc[-1])) cc +\u003d GET_EXTRALEN(cc[-1]);","#endif","break;","","case OP_TYPEPLUS:","case OP_TYPEMINPLUS:","case OP_TYPEPOSPLUS:","branchlength++;","cc +\u003d (cc[1] \u003d\u003d OP_PROP || cc[1] \u003d\u003d OP_NOTPROP)? 4 : 2;","break;","","/* Handle exact repetitions. The count is already in characters, but we","need to skip over a multibyte character in UTF8 mode. */","","case OP_EXACT:","case OP_EXACTI:","case OP_NOTEXACT:","case OP_NOTEXACTI:","branchlength +\u003d GET2(cc,1);","cc +\u003d 2 + IMM2_SIZE;","#ifdef SUPPORT_UTF","if (utf \u0026\u0026 HAS_EXTRALEN(cc[-1])) cc +\u003d GET_EXTRALEN(cc[-1]);","#endif","break;","","case OP_TYPEEXACT:","branchlength +\u003d GET2(cc,1);","cc +\u003d 2 + IMM2_SIZE + ((cc[1 + IMM2_SIZE] \u003d\u003d OP_PROP","|| cc[1 + IMM2_SIZE] \u003d\u003d OP_NOTPROP)? 2 : 0);","break;","","/* Handle single-char non-literal matchers */","","case OP_PROP:","case OP_NOTPROP:","cc +\u003d 2;","/* Fall through */","","case OP_NOT_DIGIT:","case OP_DIGIT:","case OP_NOT_WHITESPACE:","case OP_WHITESPACE:","case OP_NOT_WORDCHAR:","case OP_WORDCHAR:","case OP_ANY:","case OP_ALLANY:","case OP_EXTUNI:","case OP_HSPACE:","case OP_NOT_HSPACE:","case OP_VSPACE:","case OP_NOT_VSPACE:","branchlength++;","cc++;","break;","","/* \"Any newline\" might match two characters, but it also might match just","one. */","","case OP_ANYNL:","branchlength +\u003d 1;","cc++;","break;","","/* The single-byte matcher means we can\u0027t proceed in UTF-8 mode. (In","non-UTF-8 mode \\C will actually be turned into OP_ALLANY, so won\u0027t ever","appear, but leave the code, just in case.) */","","case OP_ANYBYTE:","#ifdef SUPPORT_UTF","if (utf) return -1;","#endif","branchlength++;","cc++;","break;","","/* For repeated character types, we have to test for \\p and \\P, which have","an extra two bytes of parameters. */","","case OP_TYPESTAR:","case OP_TYPEMINSTAR:","case OP_TYPEQUERY:","case OP_TYPEMINQUERY:","case OP_TYPEPOSSTAR:","case OP_TYPEPOSQUERY:","if (cc[1] \u003d\u003d OP_PROP || cc[1] \u003d\u003d OP_NOTPROP) cc +\u003d 2;","cc +\u003d PRIV(OP_lengths)[op];","break;","","case OP_TYPEUPTO:","case OP_TYPEMINUPTO:","case OP_TYPEPOSUPTO:","if (cc[1 + IMM2_SIZE] \u003d\u003d OP_PROP","|| cc[1 + IMM2_SIZE] \u003d\u003d OP_NOTPROP) cc +\u003d 2;","cc +\u003d PRIV(OP_lengths)[op];","break;","","/* Check a class for variable quantification */","","#if defined SUPPORT_UTF || !defined COMPILE_PCRE8","case OP_XCLASS:","cc +\u003d GET(cc, 1) - PRIV(OP_lengths)[OP_CLASS];","/* Fall through */","#endif","","case OP_CLASS:","case OP_NCLASS:","cc +\u003d PRIV(OP_lengths)[OP_CLASS];","","switch (*cc)","{","case OP_CRPLUS:","case OP_CRMINPLUS:","branchlength++;","/* Fall through */","","case OP_CRSTAR:","case OP_CRMINSTAR:","case OP_CRQUERY:","case OP_CRMINQUERY:","cc++;","break;","","case OP_CRRANGE:","case OP_CRMINRANGE:","branchlength +\u003d GET2(cc,1);","cc +\u003d 1 + 2 * IMM2_SIZE;","break;","","default:","branchlength++;","break;","}","break;","","/* Backreferences and subroutine calls are treated in the same way: we find","the minimum length for the subpattern. A recursion, however, causes an","a flag to be set that causes the length of this branch to be ignored. The","logic is that a recursion can only make sense if there is another","alternation that stops the recursing. That will provide the minimum length","(when no recursion happens). A backreference within the group that it is","referencing behaves in the same way.","","If PCRE_JAVASCRIPT_COMPAT is set, a backreference to an unset bracket","matches an empty string (by default it causes a matching failure), so in","that case we must set the minimum length to zero. */","","case OP_REF:","case OP_REFI:","if ((options \u0026 PCRE_JAVASCRIPT_COMPAT) \u003d\u003d 0)","{","ce \u003d cs \u003d (pcre_uchar *)PRIV(find_bracket)(startcode, utf, GET2(cc, 1));","if (cs \u003d\u003d NULL) return -2;","do ce +\u003d GET(ce, 1); while (*ce \u003d\u003d OP_ALT);","if (cc \u003e cs \u0026\u0026 cc \u003c ce)","{","d \u003d 0;","had_recurse \u003d TRUE;","}","else","{","d \u003d find_minlength(cs, startcode, options, recurse_depth);","}","}","else d \u003d 0;","cc +\u003d 1 + IMM2_SIZE;","","/* Handle repeated back references */","","switch (*cc)","{","case OP_CRSTAR:","case OP_CRMINSTAR:","case OP_CRQUERY:","case OP_CRMINQUERY:","min \u003d 0;","cc++;","break;","","case OP_CRPLUS:","case OP_CRMINPLUS:","min \u003d 1;","cc++;","break;","","case OP_CRRANGE:","case OP_CRMINRANGE:","min \u003d GET2(cc, 1);","cc +\u003d 1 + 2 * IMM2_SIZE;","break;","","default:","min \u003d 1;","break;","}","","branchlength +\u003d min * d;","break;","","/* We can easily detect direct recursion, but not mutual recursion. This is","caught by a recursion depth count. */","","case OP_RECURSE:","cs \u003d ce \u003d (pcre_uchar *)startcode + GET(cc, 1);","do ce +\u003d GET(ce, 1); while (*ce \u003d\u003d OP_ALT);","if ((cc \u003e cs \u0026\u0026 cc \u003c ce) || recurse_depth \u003e 10)","had_recurse \u003d TRUE;","else","{","branchlength +\u003d find_minlength(cs, startcode, options, recurse_depth + 1);","}","cc +\u003d 1 + LINK_SIZE;","break;","","/* Anything else does not or need not match a character. We can get the","item\u0027s length from the table, but for those that can match zero occurrences","of a character, we must take special action for UTF-8 characters. As it","happens, the \"NOT\" versions of these opcodes are used at present only for","ASCII characters, so they could be omitted from this list. However, in","future that may change, so we include them here so as not to leave a","gotcha for a future maintainer. */","","case OP_UPTO:","case OP_UPTOI:","case OP_NOTUPTO:","case OP_NOTUPTOI:","case OP_MINUPTO:","case OP_MINUPTOI:","case OP_NOTMINUPTO:","case OP_NOTMINUPTOI:","case OP_POSUPTO:","case OP_POSUPTOI:","case OP_NOTPOSUPTO:","case OP_NOTPOSUPTOI:","","case OP_STAR:","case OP_STARI:","case OP_NOTSTAR:","case OP_NOTSTARI:","case OP_MINSTAR:","case OP_MINSTARI:","case OP_NOTMINSTAR:","case OP_NOTMINSTARI:","case OP_POSSTAR:","case OP_POSSTARI:","case OP_NOTPOSSTAR:","case OP_NOTPOSSTARI:","","case OP_QUERY:","case OP_QUERYI:","case OP_NOTQUERY:","case OP_NOTQUERYI:","case OP_MINQUERY:","case OP_MINQUERYI:","case OP_NOTMINQUERY:","case OP_NOTMINQUERYI:","case OP_POSQUERY:","case OP_POSQUERYI:","case OP_NOTPOSQUERY:","case OP_NOTPOSQUERYI:","","cc +\u003d PRIV(OP_lengths)[op];","#ifdef SUPPORT_UTF","if (utf \u0026\u0026 HAS_EXTRALEN(cc[-1])) cc +\u003d GET_EXTRALEN(cc[-1]);","#endif","break;","","/* Skip these, but we need to add in the name length. */","","case OP_MARK:","case OP_PRUNE_ARG:","case OP_SKIP_ARG:","case OP_THEN_ARG:","cc +\u003d PRIV(OP_lengths)[op] + cc[1];","break;","","/* The remaining opcodes are just skipped over. */","","case OP_CLOSE:","case OP_COMMIT:","case OP_FAIL:","case OP_PRUNE:","case OP_SET_SOM:","case OP_SKIP:","case OP_THEN:","cc +\u003d PRIV(OP_lengths)[op];","break;","","/* This should not occur: we list all opcodes explicitly so that when","new ones get added they are properly considered. */","","default:","return -3;","}","}","/* Control never gets here */","}","","","","/*************************************************","* Set a bit and maybe its alternate case *","*************************************************/","","/* Given a character, set its first byte\u0027s bit in the table, and also the","corresponding bit for the other version of a letter if we are caseless. In","UTF-8 mode, for characters greater than 127, we can only do the caseless thing","when Unicode property support is available.","","Arguments:","start_bits points to the bit map","p points to the character","caseless the caseless flag","cd the block with char table pointers","utf TRUE for UTF-8 / UTF-16 mode","","Returns: pointer after the character","*/","","static const pcre_uchar *","set_table_bit(pcre_uint8 *start_bits, const pcre_uchar *p, BOOL caseless,","compile_data *cd, BOOL utf)","{","unsigned int c \u003d *p;","","#ifdef COMPILE_PCRE8","SET_BIT(c);","","#ifdef SUPPORT_UTF","if (utf \u0026\u0026 c \u003e 127)","{","GETCHARINC(c, p);","#ifdef SUPPORT_UCP","if (caseless)","{","pcre_uchar buff[6];","c \u003d UCD_OTHERCASE(c);","(void)PRIV(ord2utf)(c, buff);","SET_BIT(buff[0]);","}","#endif","return p;","}","#endif","","/* Not UTF-8 mode, or character is less than 127. */","","if (caseless \u0026\u0026 (cd-\u003ectypes[c] \u0026 ctype_letter) !\u003d 0) SET_BIT(cd-\u003efcc[c]);","return p + 1;","#endif","","#ifdef COMPILE_PCRE16","if (c \u003e 0xff)","{","c \u003d 0xff;","caseless \u003d FALSE;","}","SET_BIT(c);","","#ifdef SUPPORT_UTF","if (utf \u0026\u0026 c \u003e 127)","{","GETCHARINC(c, p);","#ifdef SUPPORT_UCP","if (caseless)","{","c \u003d UCD_OTHERCASE(c);","if (c \u003e 0xff)","c \u003d 0xff;","SET_BIT(c);","}","#endif","return p;","}","#endif","","if (caseless \u0026\u0026 (cd-\u003ectypes[c] \u0026 ctype_letter) !\u003d 0) SET_BIT(cd-\u003efcc[c]);","return p + 1;","#endif","}","","","","/*************************************************","* Set bits for a positive character type *","*************************************************/","","/* This function sets starting bits for a character type. In UTF-8 mode, we can","only do a direct setting for bytes less than 128, as otherwise there can be","confusion with bytes in the middle of UTF-8 characters. In a \"traditional\"","environment, the tables will only recognize ASCII characters anyway, but in at","least one Windows environment, some higher bytes bits were set in the tables.","So we deal with that case by considering the UTF-8 encoding.","","Arguments:","start_bits the starting bitmap","cbit type the type of character wanted","table_limit 32 for non-UTF-8; 16 for UTF-8","cd the block with char table pointers","","Returns: nothing","*/","","static void","set_type_bits(pcre_uint8 *start_bits, int cbit_type, int table_limit,","compile_data *cd)","{","register int c;","for (c \u003d 0; c \u003c table_limit; c++) start_bits[c] |\u003d cd-\u003ecbits[c+cbit_type];","#if defined SUPPORT_UTF \u0026\u0026 defined COMPILE_PCRE8","if (table_limit \u003d\u003d 32) return;","for (c \u003d 128; c \u003c 256; c++)","{","if ((cd-\u003ecbits[c/8] \u0026 (1 \u003c\u003c (c\u00267))) !\u003d 0)","{","pcre_uchar buff[6];","(void)PRIV(ord2utf)(c, buff);","SET_BIT(buff[0]);","}","}","#endif","}","","","/*************************************************","* Set bits for a negative character type *","*************************************************/","","/* This function sets starting bits for a negative character type such as \\D.","In UTF-8 mode, we can only do a direct setting for bytes less than 128, as","otherwise there can be confusion with bytes in the middle of UTF-8 characters.","Unlike in the positive case, where we can set appropriate starting bits for","specific high-valued UTF-8 characters, in this case we have to set the bits for","all high-valued characters. The lowest is 0xc2, but we overkill by starting at","0xc0 (192) for simplicity.","","Arguments:","start_bits the starting bitmap","cbit type the type of character wanted","table_limit 32 for non-UTF-8; 16 for UTF-8","cd the block with char table pointers","","Returns: nothing","*/","","static void","set_nottype_bits(pcre_uint8 *start_bits, int cbit_type, int table_limit,","compile_data *cd)","{","register int c;","for (c \u003d 0; c \u003c table_limit; c++) start_bits[c] |\u003d ~cd-\u003ecbits[c+cbit_type];","#if defined SUPPORT_UTF \u0026\u0026 defined COMPILE_PCRE8","if (table_limit !\u003d 32) for (c \u003d 24; c \u003c 32; c++) start_bits[c] \u003d 0xff;","#endif","}","","","","/*************************************************","* Create bitmap of starting bytes *","*************************************************/","","/* This function scans a compiled unanchored expression recursively and","attempts to build a bitmap of the set of possible starting bytes. As time goes","by, we may be able to get more clever at doing this. The SSB_CONTINUE return is","useful for parenthesized groups in patterns such as (a*)b where the group","provides some optional starting bytes but scanning must continue at the outer","level to find at least one mandatory byte. At the outermost level, this","function fails unless the result is SSB_DONE.","","Arguments:","code points to an expression","start_bits points to a 32-byte table, initialized to 0","utf TRUE if in UTF-8 / UTF-16 mode","cd the block with char table pointers","","Returns: SSB_FAIL \u003d\u003e Failed to find any starting bytes","SSB_DONE \u003d\u003e Found mandatory starting bytes","SSB_CONTINUE \u003d\u003e Found optional starting bytes","SSB_UNKNOWN \u003d\u003e Hit an unrecognized opcode","*/","","static int","set_start_bits(const pcre_uchar *code, pcre_uint8 *start_bits, BOOL utf,","compile_data *cd)","{","register int c;","int yield \u003d SSB_DONE;","#if defined SUPPORT_UTF \u0026\u0026 defined COMPILE_PCRE8","int table_limit \u003d utf? 16:32;","#else","int table_limit \u003d 32;","#endif","","#if 0","/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */","/* The following comment and code was inserted in January 1999. In May 2006,","when it was observed to cause compiler warnings about unused values, I took it","out again. If anybody is still using OS/2, they will have to put it back","manually. */","","/* This next statement and the later reference to dummy are here in order to","trick the optimizer of the IBM C compiler for OS/2 into generating correct","code. Apparently IBM isn\u0027t going to fix the problem, and we would rather not","disable optimization (in this module it actually makes a big difference, and","the pcre module can use all the optimization it can get). */","","volatile int dummy;","/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */","#endif","","do","{","BOOL try_next \u003d TRUE;","const pcre_uchar *tcode \u003d code + 1 + LINK_SIZE;","","if (*code \u003d\u003d OP_CBRA || *code \u003d\u003d OP_SCBRA ||","*code \u003d\u003d OP_CBRAPOS || *code \u003d\u003d OP_SCBRAPOS) tcode +\u003d IMM2_SIZE;","","while (try_next) /* Loop for items in this branch */","{","int rc;","","switch(*tcode)","{","/* If we reach something we don\u0027t understand, it means a new opcode has","been created that hasn\u0027t been added to this code. Hopefully this problem","will be discovered during testing. */","","default:","return SSB_UNKNOWN;","","/* Fail for a valid opcode that implies no starting bits. */","","case OP_ACCEPT:","case OP_ASSERT_ACCEPT:","case OP_ALLANY:","case OP_ANY:","case OP_ANYBYTE:","case OP_CIRC:","case OP_CIRCM:","case OP_CLOSE:","case OP_COMMIT:","case OP_COND:","case OP_CREF:","case OP_DEF:","case OP_DOLL:","case OP_DOLLM:","case OP_END:","case OP_EOD:","case OP_EODN:","case OP_EXTUNI:","case OP_FAIL:","case OP_MARK:","case OP_NCREF:","case OP_NOT:","case OP_NOTEXACT:","case OP_NOTEXACTI:","case OP_NOTI:","case OP_NOTMINPLUS:","case OP_NOTMINPLUSI:","case OP_NOTMINQUERY:","case OP_NOTMINQUERYI:","case OP_NOTMINSTAR:","case OP_NOTMINSTARI:","case OP_NOTMINUPTO:","case OP_NOTMINUPTOI:","case OP_NOTPLUS:","case OP_NOTPLUSI:","case OP_NOTPOSPLUS:","case OP_NOTPOSPLUSI:","case OP_NOTPOSQUERY:","case OP_NOTPOSQUERYI:","case OP_NOTPOSSTAR:","case OP_NOTPOSSTARI:","case OP_NOTPOSUPTO:","case OP_NOTPOSUPTOI:","case OP_NOTPROP:","case OP_NOTQUERY:","case OP_NOTQUERYI:","case OP_NOTSTAR:","case OP_NOTSTARI:","case OP_NOTUPTO:","case OP_NOTUPTOI:","case OP_NOT_HSPACE:","case OP_NOT_VSPACE:","case OP_NRREF:","case OP_PROP:","case OP_PRUNE:","case OP_PRUNE_ARG:","case OP_RECURSE:","case OP_REF:","case OP_REFI:","case OP_REVERSE:","case OP_RREF:","case OP_SCOND:","case OP_SET_SOM:","case OP_SKIP:","case OP_SKIP_ARG:","case OP_SOD:","case OP_SOM:","case OP_THEN:","case OP_THEN_ARG:","#if defined SUPPORT_UTF || !defined COMPILE_PCRE8","case OP_XCLASS:","#endif","return SSB_FAIL;","","/* We can ignore word boundary tests. */","","case OP_WORD_BOUNDARY:","case OP_NOT_WORD_BOUNDARY:","tcode++;","break;","","/* If we hit a bracket or a positive lookahead assertion, recurse to set","bits from within the subpattern. If it can\u0027t find anything, we have to","give up. If it finds some mandatory character(s), we are done for this","branch. Otherwise, carry on scanning after the subpattern. */","","case OP_BRA:","case OP_SBRA:","case OP_CBRA:","case OP_SCBRA:","case OP_BRAPOS:","case OP_SBRAPOS:","case OP_CBRAPOS:","case OP_SCBRAPOS:","case OP_ONCE:","case OP_ONCE_NC:","case OP_ASSERT:","rc \u003d set_start_bits(tcode, start_bits, utf, cd);","if (rc \u003d\u003d SSB_FAIL || rc \u003d\u003d SSB_UNKNOWN) return rc;","if (rc \u003d\u003d SSB_DONE) try_next \u003d FALSE; else","{","do tcode +\u003d GET(tcode, 1); while (*tcode \u003d\u003d OP_ALT);","tcode +\u003d 1 + LINK_SIZE;","}","break;","","/* If we hit ALT or KET, it means we haven\u0027t found anything mandatory in","this branch, though we might have found something optional. For ALT, we","continue with the next alternative, but we have to arrange that the final","result from subpattern is SSB_CONTINUE rather than SSB_DONE. For KET,","return SSB_CONTINUE: if this is the top level, that indicates failure,","but after a nested subpattern, it causes scanning to continue. */","","case OP_ALT:","yield \u003d SSB_CONTINUE;","try_next \u003d FALSE;","break;","","case OP_KET:","case OP_KETRMAX:","case OP_KETRMIN:","case OP_KETRPOS:","return SSB_CONTINUE;","","/* Skip over callout */","","case OP_CALLOUT:","tcode +\u003d 2 + 2*LINK_SIZE;","break;","","/* Skip over lookbehind and negative lookahead assertions */","","case OP_ASSERT_NOT:","case OP_ASSERTBACK:","case OP_ASSERTBACK_NOT:","do tcode +\u003d GET(tcode, 1); while (*tcode \u003d\u003d OP_ALT);","tcode +\u003d 1 + LINK_SIZE;","break;","","/* BRAZERO does the bracket, but carries on. */","","case OP_BRAZERO:","case OP_BRAMINZERO:","case OP_BRAPOSZERO:","rc \u003d set_start_bits(++tcode, start_bits, utf, cd);","if (rc \u003d\u003d SSB_FAIL || rc \u003d\u003d SSB_UNKNOWN) return rc;","/* \u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d","See the comment at the head of this function concerning the next line,","which was an old fudge for the benefit of OS/2.","dummy \u003d 1;","\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d */","do tcode +\u003d GET(tcode,1); while (*tcode \u003d\u003d OP_ALT);","tcode +\u003d 1 + LINK_SIZE;","break;","","/* SKIPZERO skips the bracket. */","","case OP_SKIPZERO:","tcode++;","do tcode +\u003d GET(tcode,1); while (*tcode \u003d\u003d OP_ALT);","tcode +\u003d 1 + LINK_SIZE;","break;","","/* Single-char * or ? sets the bit and tries the next item */","","case OP_STAR:","case OP_MINSTAR:","case OP_POSSTAR:","case OP_QUERY:","case OP_MINQUERY:","case OP_POSQUERY:","tcode \u003d set_table_bit(start_bits, tcode + 1, FALSE, cd, utf);","break;","","case OP_STARI:","case OP_MINSTARI:","case OP_POSSTARI:","case OP_QUERYI:","case OP_MINQUERYI:","case OP_POSQUERYI:","tcode \u003d set_table_bit(start_bits, tcode + 1, TRUE, cd, utf);","break;","","/* Single-char upto sets the bit and tries the next */","","case OP_UPTO:","case OP_MINUPTO:","case OP_POSUPTO:","tcode \u003d set_table_bit(start_bits, tcode + 1 + IMM2_SIZE, FALSE, cd, utf);","break;","","case OP_UPTOI:","case OP_MINUPTOI:","case OP_POSUPTOI:","tcode \u003d set_table_bit(start_bits, tcode + 1 + IMM2_SIZE, TRUE, cd, utf);","break;","","/* At least one single char sets the bit and stops */","","case OP_EXACT:","tcode +\u003d IMM2_SIZE;","/* Fall through */","case OP_CHAR:","case OP_PLUS:","case OP_MINPLUS:","case OP_POSPLUS:","(void)set_table_bit(start_bits, tcode + 1, FALSE, cd, utf);","try_next \u003d FALSE;","break;","","case OP_EXACTI:","tcode +\u003d IMM2_SIZE;","/* Fall through */","case OP_CHARI:","case OP_PLUSI:","case OP_MINPLUSI:","case OP_POSPLUSI:","(void)set_table_bit(start_bits, tcode + 1, TRUE, cd, utf);","try_next \u003d FALSE;","break;","","/* Special spacing and line-terminating items. These recognize specific","lists of characters. The difference between VSPACE and ANYNL is that the","latter can match the two-character CRLF sequence, but that is not","relevant for finding the first character, so their code here is","identical. */","","case OP_HSPACE:","SET_BIT(0x09);","SET_BIT(0x20);","#ifdef SUPPORT_UTF","if (utf)","{","#ifdef COMPILE_PCRE8","SET_BIT(0xC2); /* For U+00A0 */","SET_BIT(0xE1); /* For U+1680, U+180E */","SET_BIT(0xE2); /* For U+2000 - U+200A, U+202F, U+205F */","SET_BIT(0xE3); /* For U+3000 */","#endif","#ifdef COMPILE_PCRE16","SET_BIT(0xA0);","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","else","#endif /* SUPPORT_UTF */","{","SET_BIT(0xA0);","#ifdef COMPILE_PCRE16","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","try_next \u003d FALSE;","break;","","case OP_ANYNL:","case OP_VSPACE:","SET_BIT(0x0A);","SET_BIT(0x0B);","SET_BIT(0x0C);","SET_BIT(0x0D);","#ifdef SUPPORT_UTF","if (utf)","{","#ifdef COMPILE_PCRE8","SET_BIT(0xC2); /* For U+0085 */","SET_BIT(0xE2); /* For U+2028, U+2029 */","#endif","#ifdef COMPILE_PCRE16","SET_BIT(0x85);","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","else","#endif /* SUPPORT_UTF */","{","SET_BIT(0x85);","#ifdef COMPILE_PCRE16","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","try_next \u003d FALSE;","break;","","/* Single character types set the bits and stop. Note that if PCRE_UCP","is set, we do not see these op codes because \\d etc are converted to","properties. Therefore, these apply in the case when only characters less","than 256 are recognized to match the types. */","","case OP_NOT_DIGIT:","set_nottype_bits(start_bits, cbit_digit, table_limit, cd);","try_next \u003d FALSE;","break;","","case OP_DIGIT:","set_type_bits(start_bits, cbit_digit, table_limit, cd);","try_next \u003d FALSE;","break;","","/* The cbit_space table has vertical tab as whitespace; we have to","ensure it is set as not whitespace. */","","case OP_NOT_WHITESPACE:","set_nottype_bits(start_bits, cbit_space, table_limit, cd);","start_bits[1] |\u003d 0x08;","try_next \u003d FALSE;","break;","","/* The cbit_space table has vertical tab as whitespace; we have to","not set it from the table. */","","case OP_WHITESPACE:","c \u003d start_bits[1]; /* Save in case it was already set */","set_type_bits(start_bits, cbit_space, table_limit, cd);","start_bits[1] \u003d (start_bits[1] \u0026 ~0x08) | c;","try_next \u003d FALSE;","break;","","case OP_NOT_WORDCHAR:","set_nottype_bits(start_bits, cbit_word, table_limit, cd);","try_next \u003d FALSE;","break;","","case OP_WORDCHAR:","set_type_bits(start_bits, cbit_word, table_limit, cd);","try_next \u003d FALSE;","break;","","/* One or more character type fudges the pointer and restarts, knowing","it will hit a single character type and stop there. */","","case OP_TYPEPLUS:","case OP_TYPEMINPLUS:","case OP_TYPEPOSPLUS:","tcode++;","break;","","case OP_TYPEEXACT:","tcode +\u003d 1 + IMM2_SIZE;","break;","","/* Zero or more repeats of character types set the bits and then","try again. */","","case OP_TYPEUPTO:","case OP_TYPEMINUPTO:","case OP_TYPEPOSUPTO:","tcode +\u003d IMM2_SIZE; /* Fall through */","","case OP_TYPESTAR:","case OP_TYPEMINSTAR:","case OP_TYPEPOSSTAR:","case OP_TYPEQUERY:","case OP_TYPEMINQUERY:","case OP_TYPEPOSQUERY:","switch(tcode[1])","{","default:","case OP_ANY:","case OP_ALLANY:","return SSB_FAIL;","","case OP_HSPACE:","SET_BIT(0x09);","SET_BIT(0x20);","#ifdef COMPILE_PCRE8","if (utf)","{","#ifdef COMPILE_PCRE8","SET_BIT(0xC2); /* For U+00A0 */","SET_BIT(0xE1); /* For U+1680, U+180E */","SET_BIT(0xE2); /* For U+2000 - U+200A, U+202F, U+205F */","SET_BIT(0xE3); /* For U+3000 */","#endif","#ifdef COMPILE_PCRE16","SET_BIT(0xA0);","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","else","#endif /* SUPPORT_UTF */","SET_BIT(0xA0);","break;","","case OP_ANYNL:","case OP_VSPACE:","SET_BIT(0x0A);","SET_BIT(0x0B);","SET_BIT(0x0C);","SET_BIT(0x0D);","#ifdef COMPILE_PCRE8","if (utf)","{","#ifdef COMPILE_PCRE8","SET_BIT(0xC2); /* For U+0085 */","SET_BIT(0xE2); /* For U+2028, U+2029 */","#endif","#ifdef COMPILE_PCRE16","SET_BIT(0x85);","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","}","else","#endif /* SUPPORT_UTF */","SET_BIT(0x85);","break;","","case OP_NOT_DIGIT:","set_nottype_bits(start_bits, cbit_digit, table_limit, cd);","break;","","case OP_DIGIT:","set_type_bits(start_bits, cbit_digit, table_limit, cd);","break;","","/* The cbit_space table has vertical tab as whitespace; we have to","ensure it gets set as not whitespace. */","","case OP_NOT_WHITESPACE:","set_nottype_bits(start_bits, cbit_space, table_limit, cd);","start_bits[1] |\u003d 0x08;","break;","","/* The cbit_space table has vertical tab as whitespace; we have to","avoid setting it. */","","case OP_WHITESPACE:","c \u003d start_bits[1]; /* Save in case it was already set */","set_type_bits(start_bits, cbit_space, table_limit, cd);","start_bits[1] \u003d (start_bits[1] \u0026 ~0x08) | c;","break;","","case OP_NOT_WORDCHAR:","set_nottype_bits(start_bits, cbit_word, table_limit, cd);","break;","","case OP_WORDCHAR:","set_type_bits(start_bits, cbit_word, table_limit, cd);","break;","}","","tcode +\u003d 2;","break;","","/* Character class where all the information is in a bit map: set the","bits and either carry on or not, according to the repeat count. If it was","a negative class, and we are operating with UTF-8 characters, any byte","with a value \u003e\u003d 0xc4 is a potentially valid starter because it starts a","character with a value \u003e 255. */","","case OP_NCLASS:","#if defined SUPPORT_UTF \u0026\u0026 defined COMPILE_PCRE8","if (utf)","{","start_bits[24] |\u003d 0xf0; /* Bits for 0xc4 - 0xc8 */","memset(start_bits+25, 0xff, 7); /* Bits for 0xc9 - 0xff */","}","#endif","#ifdef COMPILE_PCRE16","SET_BIT(0xFF); /* For characters \u003e 255 */","#endif","/* Fall through */","","case OP_CLASS:","{","pcre_uint8 *map;","tcode++;","map \u003d (pcre_uint8 *)tcode;","","/* In UTF-8 mode, the bits in a bit map correspond to character","values, not to byte values. However, the bit map we are constructing is","for byte values. So we have to do a conversion for characters whose","value is \u003e 127. In fact, there are only two possible starting bytes for","characters in the range 128 - 255. */","","#if defined SUPPORT_UTF \u0026\u0026 defined COMPILE_PCRE8","if (utf)","{","for (c \u003d 0; c \u003c 16; c++) start_bits[c] |\u003d map[c];","for (c \u003d 128; c \u003c 256; c++)","{","if ((map[c/8] \u0026\u0026 (1 \u003c\u003c (c\u00267))) !\u003d 0)","{","int d \u003d (c \u003e\u003e 6) | 0xc0; /* Set bit for this starter */","start_bits[d/8] |\u003d (1 \u003c\u003c (d\u00267)); /* and then skip on to the */","c \u003d (c \u0026 0xc0) + 0x40 - 1; /* next relevant character. */","}","}","}","else","#endif","{","/* In non-UTF-8 mode, the two bit maps are completely compatible. */","for (c \u003d 0; c \u003c 32; c++) start_bits[c] |\u003d map[c];","}","","/* Advance past the bit map, and act on what follows. For a zero","minimum repeat, continue; otherwise stop processing. */","","tcode +\u003d 32 / sizeof(pcre_uchar);","switch (*tcode)","{","case OP_CRSTAR:","case OP_CRMINSTAR:","case OP_CRQUERY:","case OP_CRMINQUERY:","tcode++;","break;","","case OP_CRRANGE:","case OP_CRMINRANGE:","if (GET2(tcode, 1) \u003d\u003d 0) tcode +\u003d 1 + 2 * IMM2_SIZE;","else try_next \u003d FALSE;","break;","","default:","try_next \u003d FALSE;","break;","}","}","break; /* End of bitmap class handling */","","} /* End of switch */","} /* End of try_next loop */","","code +\u003d GET(code, 1); /* Advance to next branch */","}","while (*code \u003d\u003d OP_ALT);","return yield;","}","","","","","","/*************************************************","* Study a compiled expression *","*************************************************/","","/* This function is handed a compiled expression that it must study to produce","information that will speed up the matching. It returns a pcre[16]_extra block","which then gets handed back to pcre_exec().","","Arguments:","re points to the compiled expression","options contains option bits","errorptr points to where to place error messages;","set NULL unless error","","Returns: pointer to a pcre[16]_extra block, with study_data filled in and","the appropriate flags set;","NULL on error or if no optimization possible","*/","","#ifdef COMPILE_PCRE8","PCRE_EXP_DEFN pcre_extra * PCRE_CALL_CONVENTION","pcre_study(const pcre *external_re, int options, const char **errorptr)","#else","PCRE_EXP_DEFN pcre16_extra * PCRE_CALL_CONVENTION","pcre16_study(const pcre16 *external_re, int options, const char **errorptr)","#endif","{","int min;","BOOL bits_set \u003d FALSE;","pcre_uint8 start_bits[32];","PUBL(extra) *extra \u003d NULL;","pcre_study_data *study;","const pcre_uint8 *tables;","pcre_uchar *code;","compile_data compile_block;","const REAL_PCRE *re \u003d (const REAL_PCRE *)external_re;","","*errorptr \u003d NULL;","","if (re \u003d\u003d NULL || re-\u003emagic_number !\u003d MAGIC_NUMBER)","{","*errorptr \u003d \"argument is not a compiled regular expression\";","return NULL;","}","","if ((re-\u003eflags \u0026 PCRE_MODE) \u003d\u003d 0)","{","#ifdef COMPILE_PCRE8","*errorptr \u003d \"argument is compiled in 16 bit mode\";","#else","*errorptr \u003d \"argument is compiled in 8 bit mode\";","#endif","return NULL;","}","","if ((options \u0026 ~PUBLIC_STUDY_OPTIONS) !\u003d 0)","{","*errorptr \u003d \"unknown or incorrect option bit(s) set\";","return NULL;","}","","code \u003d (pcre_uchar *)re + re-\u003ename_table_offset +","(re-\u003ename_count * re-\u003ename_entry_size);","","/* For an anchored pattern, or an unanchored pattern that has a first char, or","a multiline pattern that matches only at \"line starts\", there is no point in","seeking a list of starting bytes. */","","if ((re-\u003eoptions \u0026 PCRE_ANCHORED) \u003d\u003d 0 \u0026\u0026","(re-\u003eflags \u0026 (PCRE_FIRSTSET|PCRE_STARTLINE)) \u003d\u003d 0)","{","int rc;","","/* Set the character tables in the block that is passed around */","","tables \u003d re-\u003etables;","","#ifdef COMPILE_PCRE8","if (tables \u003d\u003d NULL)","(void)pcre_fullinfo(external_re, NULL, PCRE_INFO_DEFAULT_TABLES,","(void *)(\u0026tables));","#else","if (tables \u003d\u003d NULL)","(void)pcre16_fullinfo(external_re, NULL, PCRE_INFO_DEFAULT_TABLES,","(void *)(\u0026tables));","#endif","","compile_block.lcc \u003d tables + lcc_offset;","compile_block.fcc \u003d tables + fcc_offset;","compile_block.cbits \u003d tables + cbits_offset;","compile_block.ctypes \u003d tables + ctypes_offset;","","/* See if we can find a fixed set of initial characters for the pattern. */","","memset(start_bits, 0, 32 * sizeof(pcre_uint8));","rc \u003d set_start_bits(code, start_bits, (re-\u003eoptions \u0026 PCRE_UTF8) !\u003d 0,","\u0026compile_block);","bits_set \u003d rc \u003d\u003d SSB_DONE;","if (rc \u003d\u003d SSB_UNKNOWN)","{","*errorptr \u003d \"internal error: opcode not recognized\";","return NULL;","}","}","","/* Find the minimum length of subject string. */","","switch(min \u003d find_minlength(code, code, re-\u003eoptions, 0))","{","case -2: *errorptr \u003d \"internal error: missing capturing bracket\"; return NULL;","case -3: *errorptr \u003d \"internal error: opcode not recognized\"; return NULL;","default: break;","}","","/* If a set of starting bytes has been identified, or if the minimum length is","greater than zero, or if JIT optimization has been requested, get a","pcre[16]_extra block and a pcre_study_data block. The study data is put in the","latter, which is pointed to by the former, which may also get additional data","set later by the calling program. At the moment, the size of pcre_study_data","is fixed. We nevertheless save it in a field for returning via the","pcre_fullinfo() function so that if it becomes variable in the future,","we don\u0027t have to change that code. */","","if (bits_set || min \u003e 0","#ifdef SUPPORT_JIT","|| (options \u0026 PCRE_STUDY_JIT_COMPILE) !\u003d 0","#endif",")","{","extra \u003d (PUBL(extra) *)(PUBL(malloc))","(sizeof(PUBL(extra)) + sizeof(pcre_study_data));","if (extra \u003d\u003d NULL)","{","*errorptr \u003d \"failed to get memory\";","return NULL;","}","","study \u003d (pcre_study_data *)((char *)extra + sizeof(PUBL(extra)));","extra-\u003eflags \u003d PCRE_EXTRA_STUDY_DATA;","extra-\u003estudy_data \u003d study;","","study-\u003esize \u003d sizeof(pcre_study_data);","study-\u003eflags \u003d 0;","","/* Set the start bits always, to avoid unset memory errors if the","study data is written to a file, but set the flag only if any of the bits","are set, to save time looking when none are. */","","if (bits_set)","{","study-\u003eflags |\u003d PCRE_STUDY_MAPPED;","memcpy(study-\u003estart_bits, start_bits, sizeof(start_bits));","}","else memset(study-\u003estart_bits, 0, 32 * sizeof(pcre_uint8));","","#ifdef PCRE_DEBUG","if (bits_set)","{","pcre_uint8 *ptr \u003d (pcre_uint32 *)start_bits;","int i;","","printf(\"Start bits:\\n\");","for (i \u003d 0; i \u003c 32; i++)","printf(\"%3d: %02x%s\", i * 8, *ptr++, ((i + 1) \u0026 0x7) !\u003d 0? \" \" : \"\\n\");","}","#endif","","/* Always set the minlength value in the block, because the JIT compiler","makes use of it. However, don\u0027t set the bit unless the length is greater than","zero - the interpretive pcre_exec() and pcre_dfa_exec() needn\u0027t waste time","checking the zero case. */","","if (min \u003e 0)","{","study-\u003eflags |\u003d PCRE_STUDY_MINLEN;","study-\u003eminlength \u003d min;","}","else study-\u003eminlength \u003d 0;","","/* If JIT support was compiled and requested, attempt the JIT compilation.","If no starting bytes were found, and the minimum length is zero, and JIT","compilation fails, abandon the extra block and return NULL. */","","#ifdef SUPPORT_JIT","extra-\u003eexecutable_jit \u003d NULL;","if ((options \u0026 PCRE_STUDY_JIT_COMPILE) !\u003d 0) PRIV(jit_compile)(re, extra);","if (study-\u003eflags \u003d\u003d 0 \u0026\u0026 (extra-\u003eflags \u0026 PCRE_EXTRA_EXECUTABLE_JIT) \u003d\u003d 0)","{","#ifdef COMPILE_PCRE8","pcre_free_study(extra);","#endif","#ifdef COMPILE_PCRE16","pcre16_free_study(extra);","#endif","extra \u003d NULL;","}","#endif","}","","return extra;","}","","","/*************************************************","* Free the study data *","*************************************************/","","/* This function frees the memory that was obtained by pcre_study().","","Argument: a pointer to the pcre[16]_extra block","Returns: nothing","*/","","#ifdef COMPILE_PCRE8","PCRE_EXP_DEFN void","pcre_free_study(pcre_extra *extra)","#else","PCRE_EXP_DEFN void","pcre16_free_study(pcre16_extra *extra)","#endif","{","if (extra \u003d\u003d NULL)","return;","#ifdef SUPPORT_JIT","if ((extra-\u003eflags \u0026 PCRE_EXTRA_EXECUTABLE_JIT) !\u003d 0 \u0026\u0026","extra-\u003eexecutable_jit !\u003d NULL)","PRIV(jit_free)(extra-\u003eexecutable_jit);","#endif","PUBL(free)(extra);","}","","/* End of pcre_study.c */"]],"pageTitle":"[pcre] Contents of /code/trunk/pcre_study.c","title":"","url":"http://vcs.pcre.org/pcre/code/trunk/pcre_study.c?revision\u003d852\u0026view\u003dmarkup\u0026sortby\u003dauthor\u0026pathrev\u003d891","hasHeader":false,"headerPosition":"NONE","tableType":"ENTITY","tableNum":1,"s3Link":"common-crawl/crawl-data/CC-MAIN-2015-32/segments/1438042981969.11/warc/CC-MAIN-20150728002301-00077-ip-10-236-191-2.ec2.internal.warc.gz","recordEndOffset":244890743,"recordOffset":244860634,"tableOrientation":"HORIZONTAL","textBeforeTable":"Add pcre16 prefix to 16 bit structs File size: 42455 byte(s) File MIME type: text/plain zherczeg Thu Jan 5 19:18:12 2012 UTC (3 years, 6 months ago) by show annotations) 852 - ( Revision Parent Directory | Revision Log Contents of /code/trunk/pcre_study.c /[pcre]/code/trunk/pcre_study.c","textAfterTable":"Properties Name Value svn:eol-style native svn:keywords \"Author Date Id Revision Url\"   ViewVC Help Powered by ViewVC 1.1.5  ","hasKeyColumn":false,"keyColumnIndex":-1,"headerRowIndex":-1}